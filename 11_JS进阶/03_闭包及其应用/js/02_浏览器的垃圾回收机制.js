// /* 
// EC(G)
//   VO(G)
//     x->5
//     fn->0x000 [[scope]]: EC(G)
//     f->0x001 [[scope]]: EC(FN1)
//   代码执行

// */
// let x = 5;
// // 0x000
// const fn = function fn(x) {
//   /* 
//   fn(6)->0x000(6) 函数执行形成一个私有的上下文
//   EC(FN1)
//     AO(FN1)
//       x->6->7(F1)->8(F3)
//     作用域链：<EC(FN1),EC(G)>
//     形参赋值：x=6
//     变量提升：--
//     代码执行：返回小函数0x001
//   */
//   /* 
//   fn(8)->0x000(8)  EC(FN2)
//     AO(FN2)
//       x->8->9(F2)
//     作用域链：<EC(FN2),EC(G)>
//     形参赋值：x=8
//     变量提升：--
//     代码执行：返回小函数0x001
//   */
//   // 0x001
//   return function (y) {
//     /* 
//     f(7)->0x001(7) => EC(F1)
//       AO(F1)
//         y->7
//       作用域链：<EC(F1),EC(FN1)>
//       形参赋值：y=7
//       代码执行
//         y是私有的，x是上级上下文FN1的
//         7+7=14  
//     */
//     /* 
//     fn(8)(9) ->0x001(9) EC(F2)
//       AO(F2)
//         y->9
//       作用域链：<EC(F2),EC(FN2)>
//       形参赋值：y=9
//       代码执行
//         y是私有的，x是上级上下文FN2的
//         9+9=18
//     */
//     /* 
//     f(10)->0x001(10) => EC(F3)
//       AO(F3)
//         y->10
//       作用域链：<EC(F3),EC(FN1)>
//       形参赋值：y=10
//       代码执行
//         y是私有的，x是上级上下文FN1的
//         10+8=18  
//     */
//     console.log(y + (++x));
//   }
// };
// let f = fn(6); // 把fn执行返回的结果0x001赋值给f
// f(7); //14
// fn(8)(9); //18
// f(10); //18
// console.log(x); //5

// 拓展：去掉fn参数x「去掉上级上下文的形参x，操作的都是全局的x」
/* 
EC(G)
  VO(G)
    x->5->6(F1)->7(F2)->8(F3)
    fn->0x000 [[scope]]:EC(G)
    f->0x001 [[scope]]:EC(FN1)
*/
let x = 5;

// 0x000
function fn() {
  /* 
  fn(6)->0x000(6)  EC(FN1)
    AO(FN1)

    作用域链：<EC(FN1),EC(G)>
    形参赋值：--
    代码执行
      返回小函数0x001
  */
  /* 
  fn(8)->0x000(8)  EC(FN2)
    AO(FN2)

    作用域链：<EC(FN2),EC(G)>
    形参赋值：--
    代码执行
      返回小函数0x001
  */
  // 0x001
  return function (y) {
    /* 
    f(7)->0x001(7) EC(F1)
      AO(F1)
        y->7
        作用域链：<EC(F1),EC(FN1)>
        形参赋值：y=7
        代码执行：
          y是私有的，x是全局的
          7+6=13
    */
    /* 
    fn(8)(9) ->0x001(9) EC(F2)
      AO(F2)
        y->7
        作用域链：<EC(F2),EC(FN2)>
        形参赋值：y=9
        代码执行：
          y是私有的，x是全局的
          9+7=16
    */
    /* 
    f(10)->0x001(10) => EC(F3)
      AO(F3)
        y->10
      作用域链：<EC(F3),EC(FN1)>
      形参赋值：y=10
      代码执行
        y是私有的，x是全局的
        10+8=18  
    */
    console.log(y + (++x));
  }
}
let f = fn(6);
f(7);//13
fn(8)(9);//16
f(10);//18
console.log(x);//8

