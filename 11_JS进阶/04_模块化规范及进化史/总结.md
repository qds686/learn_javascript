单例设计模式是“最早期的模块规范”，在没有CommonJS/ES6Module模块规范的时代，帮助我们实现了模块化开发
AMD(require.js)是在单例设计模式的基础上，实现了模块和模块之间的依赖管理
------------上述操作都是过去式了
当代前端开发，都是基于模块化进行开发，而模块化方案以CommonJS和ES6Module为主
  + 它们都是按照很创建一个JS就是创建一个模块来管理的「每个JS文件中的代码都是私有的」
  + CommonJS：require && module.exports
  + ES6Module:export && import

-----------

我们编写好的JS代码，可以运行的环境
@1 浏览器 <script src='xx'> 和其类似的还有webview，webview实现把我们写的H5页面嵌入到原生APP中运行
  + 支持ES6Module，但是不支持CommonJS
  + 全局对象 window
@2 Node
  + 支持CommonJS，不支持ES6Module
  + 全局对象 global
@3 webpack：基于Node实现代码的合并压缩打包，最后把打包的结果导入到浏览器中运行
  + CommonJS&&ES6Module都支持，而且支持相互之间的“混用”「原理：webpack把两种模块规范都实现了一遍」
  + 支持window&&global
@4 vite：新的工程化打包工具
  + 不是像webpack一样编译打包的，它本质就是基于ES6Module规范，实现模块之间的相互引用


最初没有模块化的时候，最基本的模块化就是 “以页面为基础分JavaScript文件”
  + 把不同功能的JavaScript代码写在不同的JavaScript文件中
  + 有公共的方法就定义在 common.js 中管理，哪个文件需要就引入即可
  + 缺点：引入不使用的大量JS代码
优化：把不同的模块按顺序引入到全局页面
  + 导致数据类型的变量「Number、String、{}、[]」重名，污染全局作用域

模块化解决的问题：加载顺序 和 污染全局

立即执行函数的由来：一个函数想要执行，函数体必须变为表达式才能跟执行
  + 这些( + - ~ () )都可以把函数变为表达式
  + ;(function (){})(); 立即执行函数

利用ES5立即执行函数来创建一个模块的独立作用域
  + 用对象的方式抛出变量，用一个模块名moduleX接收抛出的对象
  + 别的模块使用的时候这个模块的变量的时候，需要在模块中注入这个模块的模块名
  + 如果引入的JavaScript文件顺序不对，则获取不多对应的模块名
解决了污染全局 和 模块依赖 的问题，解决不了加载顺序的问题

利用立即执行函数可以开发一个可配置的模块，即插件化开发

NodeJS诞生带来了前所未有的模块化体验
  + require() 引入模块
  + module.exports 导出模块