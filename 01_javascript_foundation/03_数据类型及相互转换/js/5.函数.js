/**
 * 函数数据类型：
 *    函数：就是一个方法，可以实现某个功能
 */

// 实现两个数字求和再求平均值
// 当前代码数字改变需要重复写代码
var n = 10,
  m = 20;
var total = n + m;
var average = (total / 2).toFixed(2);
console.log(average); // '15.00'

// 封装实现两个不同的数字求和求平均值
/**
 * 1.创建函数
 *   + sum函数名(等同于变量，也是声明一个sum变量，只不过存储的值是一个函数)
 *   + x或者y: 形参(变量)，它是函数提供的一个入口(原因：封装这个功能，很多信息此时不清楚，执行时用户传递进来才清楚)
 *   + {...}函数体：编写具体功能代码的区域
 * 
 */

// 创建函数定义了形参，但是执行的时候没有传递实参值，则默认形参变量的值是undefined
// 形参中可以设置默认值：设定形参不传递值，走等号后面的默认值，但是一旦传递值了，不论传递什么都不会走默认值
function sum(x, y) {
  var total = x + y,
    average = (total / 2).toFixed(2);
  return average;
}
/**
 * 2.执行函数 => 函数(实参1,实参2,...)
 *   + 实参(具体的值)：就是给函数的形参变量传递的具体值
 *   + 想要获取函数返回值
 *     + 在函数外面不能访问函数体中的内容的(闭包的机制：当前上线文中的私有变量是受到保护的，不能在上下文直接的访问)
 *     + 则需要在函数中return需要返回的值，return的什么就是什么，函数调用的时候用变量接收
 *     + 不写return 或者 return啥都不返回，默认返回undefined
 *     + return的一定是一个值，return average也不是返回变量，而是把变量存储的结果返回 -> return '15.00'
 *   + 函数体中只要遇到return，函数体中，return下面的代码都不会再执行
 */
var res1 = sum(1, 2);
var res2 = sum(3, 4);
// ==========================
// 创建函数的方式：
// 声明一个变量叫做fn,只不过存储的值是一个函数
function fn() { }
// 函数表达式：在变量提升中有区别，把创建好的函数当做值，赋值给变量
var fn = function () { }

  // 自执行函数：第一个小括号中存放的是创建的函数，第二个小括号是把函数执行
  (function (x) {

  })(100);
// 除了用小括号把函数包裹起来可以解决语法错误的问题，在前面加~、+、-、！也可以让语法再去
~ function (x) {
  // ...
}(100);


// ====================
// arguments
// 需求：执行函数的时候传递实参值，但是传递多少个实参“不确定”，我们想接收函数传递的实参信息
//    + 设定形参变量：但是需要知道传递实参的数量和顺序
//    + 函数内置实参集合 arguments：不论是否传递以及传递多少实参(也不管是否设定形参)，在集合中包含了所有传递的进来的信息
//      + 不传递就是一个空集合
//      + 这个集合是一个“类数组”
//    + ES6中的“...”剩余运算符:函数形参中的剩余运算符，可以获取到，除了前面设定形参变量接收的实参外，剩下的实参都放到这个集合中
//      + 如果一个形参变量都没有定义，则所有传递的实参信息都存到这个集合中
//      + 返回的是一个数组
function fn(...args) {
  // arguments.callee:函数本身
  // console.log(arguments);

  console.log(args);
}
fn();
fn(10);

// =======================
// ES6中创建函数的新方式：“箭头函数”
//  + 所有箭头函数都是函数表达式创建方式
//  + 创建函数的语法不一样，但是执行函数是一样的
//  + 箭头函数中没有arguments，只能用剩余运算符了
// 语法：var xx = (形参) => { 函数体 };
// var fn = () => {};
// fn();

function fn(x) {
  return function (y) {
    return x + y;
  }
}
// 改写
var fn = x => y => x + y;