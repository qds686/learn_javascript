/**
 * 首先浏览器内存分配两块内存，栈内存和堆内存
 *   + 栈内存供代码执行，存储全局的原始值和对象地址
 *   + 堆内存存储对象的键值对
 *
 * 浏览器默认在堆内存中创建GO全局对象(0x000)，存储JS的内置API 
 * 创建一个全局的执行上下文 EC(G)
 *   + 默认创建变量window，指向GO全局对象 0x000
 *   + 声明变量
 *     x -> 0x001
 *     fn -> 0x002
 *   + 代码执行
 * 
 * 创建函数的步骤：
 * 1.开辟堆内存空间，16进制地址
 * 2.存储信息
 *   + 创建函数的时候，就声明了其作用域
 *   + 把函数体中的代码当做字符串存储起来
 *   + 看做普通对象，存储键值对
 *     name函数名
 *     length形参个数
 *     prototype原型对象
 *     __proto__原型链
 * 3.把空间地址赋值给变量(函数名)
 * 
 * 函数执行步骤；
 * 1.创建一个“全新的”私有执行上下文 
 *   + EC(?)
 *   + AO(?) 默认创建私有变量对象
 * 2.代码执行之前：
 *   + 初始化作用域链<函数私有上下文，函数作用域>
 *   + 初始化this
 *   + 初始化arguments
 *   + 形参赋值 (私有变量)
 *   + 变量提升
 * 3.代码执行
 * 4.关于上下文的回收释放问题
 * 
 * 私有上下文中代码执行，如果遇到一个变量，首先看是不是自己私有的
 *   + 是，则操作自己的，和外界没有关系
 *   + 不是，则基于作用域链向其上级上下文中查找，看是否为上级上下文私有的变量，如果还找不到，则继续基于作用域链向上查找...,知道找到EC(G)为止，我们把这种机制叫“作用域链查找机制”
 */

// 创建堆内存 0x001
let x = [12, 13];
// 创建堆内存 0x002
const fn = function (y){
  /**
   * 函数执行形成私有上下文 EC(FN)
   * 
   */
  y[0] = 100;
  y = [100];
  y[1] = 200;
  console.log(y);
};
fn(x); // -> fn(0x001)
console.log(x);
